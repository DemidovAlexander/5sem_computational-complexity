\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath,amssymb}
\usepackage{listings}
\textheight=24cm % высота текста
\textwidth=16cm % ширина текста
\oddsidemargin=0pt % отступ от левого края
\topmargin=-1.5cm % отступ от верхнего края
\parindent=24pt % абзацный отступ
\parskip=0pt % интервал между абзацами
\flushbottom % выравнивание высоты страниц
\title{Полностью полиномиальная приближенная схема для~задачи~о~"Рюкзаке"}
\author{Демидов Александр, ФИВТ ПМИ группа 296}
\date{Ноябрь 2014}
\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\section*{Содержание}
\begin{enumerate}
    \item Псевдополиномиальный алгоритм (динамическое программирование)
    \item Построение полиномиальной приближенной схемы
    \item Полный код решения
    \item Результаты тестовых запусков
\end{enumerate}
\newpage
\section{Псевдополиномиальный алгоритм (динамическое\newlineпрограммирование)}
    $NP$-полная задача "Knapsack" (о "Рюкзаке") формулируется следующим образом
    
    Даны $n$ предметов, для которых заданы соответственно веса $a_1, a_2, \dots, a_n$ 
    и стоимости $c_1, c_2,\dots, c_n$, где $a_j, c_j\in\mathbb{N}$ $\forall{j\in\{1, 2,\dots, n\}}$.
    Размер рюкзака ограничен $B\in\mathbb{N}$.
    
    Найти максимальное значение $f^*$ функции $$f=\sum_{i=1}^n{c_ix_i},\ x_j\in\{0, 1\}$$ при условии $$\sum_{i=1}^n{a_ix_i}\le{B}$$
    
    Рассмотрим простейшую схему решения задачи. На $k$-ом шаге будем обновлять $0/1$-таблицу $A$ размера $B\times{f^*}$, считая что для использования доступны только первые $k$ предметов, и $\forall i,j$ $A_{i, j}=1$ соответствует достижимости состояния, а $A_{i, j}=0$ недостижимости. После $n$-ого шага ненулевая ячейка с максимальной стоимостью соотвествует~$f^*$. 
    
    Очевидный рекурсивный алгоритм дает сложность $O(nBf^*)$. Переборное решение можно улучшить, заметив, что из наборов с одинаковой стоимостью, но различной массой, достаточно учитывать только набор с меньшей массой. Таким образом, достаточно помнить не более $f^*$ значений на каждой итерации. Сложность алгоритма составит в этом случае $O(nf^*)$. Подобный алгоритм будет полиномиален только для достаточно малых $f^*$, что зависит от исходных стоимостей предметов $c_1, c_2,\dots, c_n$. 
    Ниже приводится реализация описанного псевдополиномиального алгоритма на языке $Python\ 3.0$
\newpage
\section{Построение полиномиальной приближенной схемы}
    \textbf{Определение 1.} Будем называть \textbf{$\epsilon$-оптимальным решением} допустимое решение со значением целевой функции, отличающимся от оптимального не более чем в (1 + $\epsilon$) раз.\newline\newline
    \textbf{Определение 2.} \textbf{Полностью полиномиальным приближенным алгоритмом} будем называть алгоритм, находящий $\epsilon$-оптимальное решение за время, полиномомиальное относительно длины входа и величины $\epsilon^{-1}$.\newline
    
    Далее будет предложен вариант построения полностью полиномиального приближенного алгоритма для задачи "Knapsack", на основе полученного в предыдущем пункте псевдополиномиального алгоритма. Как было замечено, построенный алгоритм имеет сложность $O(nf^*)$, т. е. он будет полиномиален только для $f^*$ ограниченных сверху некоторым полиномом. В случае больших значений $f^*$ для улучшения сложности алгоритма можно попытаться некоторым образом изменить исходные стоимости предметов $c_1, c_2,\dots, c_n$. 
    
    Рассмотрим следующий вариант масштабирования:$$(\hat{c_i} = \lfloor{c_i/\alpha}\rfloor * \alpha)$$
    
    Получена новая задача, оптимальный набор для которой не изменится, если разделить все стоимости $\hat{c_i}$ на величину $\alpha$. В этом случае оценка времени работы алгоритма динамического программирования будет выглядеть следующим образом $O(nf^*/\alpha)$. При этом оптимум для новой задачи может отличаться от $f^*$ в меньшую сторону, вследствие того что стоимости предметов могли стать меньше. Заметим также, что стоимость одного предмета не может стать меньше более чем в \alpha раз.\newline
    
    Далее нам потребуются следующие обозначения:\newline
$\hat{x_i}$ — индикатор наличия предмета в оптимальном наборе для новой задачи, $\hat{x_i}\in\{0, 1\}$\newline
$x_i^*$ — индикатор наличия предмета в оптимальном наборе для исходной задачи, $x_i^*\in\{0, 1\}$\newline
$\hat{f}$ — оптимум для новой задачи, $\hat{f}=\sum_{i=1}^n{\hat{c_i}\hat{x_i}}$\newline

    Выполнен ряд оценок:
    $$\hat{f}=\sum_{i=1}^n{\hat{c_i}\hat{x_i}}\ge
    \sum_{i=1}^n{\hat{c_i}x_i^*}\ge
    \sum_{i=1}^n{(c_i-\alpha)x_i^*}\ge
    f^*-n\alpha$$
    
    Нами получено отношение $$f^*-\hat{f}\le{n\alpha},\ \ \ \ \ (1)$$ где $f^*-\hat{f}$ можно рассматривать как показатель максимального отклонения \hat{f} от оптимума исходной задачи $f^*$. 
    
    Имея в виду что $\hat{f}\le{f^*}$ получаем, что решение задачи после масштабирования стоимостей предметов является $\epsilon$-оптимальным решением исходной задачи при выполнении следующего отношения 
    $$\hat{f}\ge{f^*/(1+\epsilon)$$ 
    
    Отсюда и из $(1)$ следует ограничение на $\alpha$ для существования $\epsilon$-оптимального решения
    $$\alpha\le\frac{\epsilon{f^*}}{(1+\epsilon)n}$$
    
    Полученное отношение усилится, если $f^*$ заменить на его нижнюю оценку $f^*_{low}$. 
    Одной из возможных оценок является тривиальная $f^*_{low}=c_{max}=\max_i c_i$. 
    Тогда $\alpha$ определим как
    $$\alpha=max\left\{1,\ \frac{\epsilon c_{max}}{(1+\epsilon)n}\right\}$$
    
    При $\alpha$, удовлетворяющем данному соотношению, решение задачи после масштабирования стоимостей предметов является $\epsilon$-оптимальным решением исходной задачи. Посмотрим, как изменилась оценка времени работы при переходе к новым весам
    $$O\left(\frac{n\hat{f}}{\alpha}\right)=O\left(\frac{n n c_{max}}{\alpha}\right)=O\left(\frac{n n c_{max}}{\frac{\epsilon c_{max}}{(1+\epsilon)n}}\right)=
    O\left(\frac{n^3(1+\epsilon)}{\epsilon}\right)=O\left(n^3/\epsilon\right)$$
    
    
\newpage
\section{Полный код решения}
\newpage
\section{Результаты тестовых запусков}
\newpage
\section*{Список литературы}
\begin{enumerate}
    \item 
\end{enumerate}

\end{document}
